<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, interactive-widget=resizes-content">
<title>pocket-claude</title>
<script src="https://cdn.jsdelivr.net/npm/marked@9/marked.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    background: #1a1a1a;
    color: #e0e0e0;
    height: 100%;
    overflow: hidden;
  }

  /* ‚îÄ‚îÄ ‰∏äÈÉ®Âõ∫ÂÆö„Ç®„É™„Ç¢ ‚îÄ‚îÄ */
  #top-bar {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 20;
  }

  /* ‚îÄ‚îÄ „Éò„ÉÉ„ÉÄ„Éº ‚îÄ‚îÄ */
  #header {
    background: #252525;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    border-bottom: 1px solid #3a3a3a;
  }

  #status-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: #555;
    flex-shrink: 0;
    transition: background 0.3s;
  }
  #status-dot.connected { background: #4CAF50; }
  #status-dot.running   { background: #FF9800; animation: pulse 1.2s infinite; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

  #model-select {
    background: #333;
    color: #ccc;
    border: 1px solid #4a4a4a;
    padding: 4px 7px;
    border-radius: 6px;
    font-size: 12px;
    flex-shrink: 0;
  }

  #reset-btn, #stop-btn, #close-tab-btn, #add-tab-btn, #history-btn {
    background: none;
    border: 1px solid #4a4a4a;
    border-radius: 6px;
    padding: 4px 9px;
    font-size: 12px;
    cursor: pointer;
    flex-shrink: 0;
  }
  #reset-btn { color: #888; }
  #reset-btn:active { background: #3a3a3a; }
  #stop-btn { color: #EF5350; border-color: #EF5350; opacity: 0.3; pointer-events: none; }
  #stop-btn.running { opacity: 1; pointer-events: auto; }
  #stop-btn:active { background: #3a2020; }

  #close-tab-btn, #add-tab-btn, #history-btn {
    font-size: 16px;
    padding: 4px 10px;
    color: #888;
    min-width: 36px;
    text-align: center;
    border: none;
  }
  #close-tab-btn { margin-left: auto; }
  #close-tab-btn:active, #add-tab-btn:active, #history-btn:active { background: #3a3a3a; color: #ccc; }
  #history-btn.active { color: #64B5F6; }

  /* ‚îÄ‚îÄ Â±•Ê≠¥„Éë„Éç„É´ ‚îÄ‚îÄ */
  #history-panel {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 30;
    background: #1a1a1a;
    flex-direction: column;
  }
  #history-panel.open { display: flex; }

  #history-header {
    background: #252525;
    padding: 10px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    border-bottom: 1px solid #3a3a3a;
    flex-shrink: 0;
  }
  #history-back {
    background: none;
    border: none;
    color: #64B5F6;
    font-size: 14px;
    cursor: pointer;
    padding: 4px 6px;
    border-radius: 6px;
  }
  #history-back:active { background: #2a2a2a; }
  #history-title {
    font-size: 14px;
    color: #e0e0e0;
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  #history-body {
    flex: 1;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* ‰∏ÄË¶ß */
  .history-item {
    padding: 12px 14px;
    border-bottom: 1px solid #2a2a2a;
    cursor: pointer;
    user-select: none;
  }
  .history-item:active { background: #252525; }
  .history-item-title {
    font-size: 13px;
    color: #e0e0e0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 3px;
  }
  .history-item-meta {
    font-size: 11px;
    color: #666;
  }

  /* Ë©≥Á¥∞ */
  .history-msg {
    padding: 10px 14px;
    border-bottom: 1px solid #252525;
    font-size: 13px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
  }
  .history-msg-user { color: #81C784; background: #1e2a1e; }
  .history-msg-assistant { color: #e0e0e0; }

  /* ÂÜçÈñã„Éú„Çø„É≥ */
  #resume-btn {
    margin: 20px 14px;
    padding: 14px 20px;
    background: #1565C0;
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 15px;
    cursor: pointer;
    width: calc(100% - 28px);
    text-align: center;
  }
  #resume-btn:active { background: #0D47A1; }

  /* ‚îÄ‚îÄ „Çø„Éñ„Éê„Éº ‚îÄ‚îÄ */
  #tab-bar {
    background: #1e1e1e;
    border-bottom: 1px solid #3a3a3a;
    display: flex;
    align-items: stretch;
    overflow-x: auto;
    scrollbar-width: none;
  }
  #tab-bar::-webkit-scrollbar { display: none; }

  .tab {
    display: flex;
    align-items: center;
    padding: 8px 14px;
    font-size: 13px;
    color: #888;
    cursor: pointer;
    white-space: nowrap;
    border-bottom: 2px solid transparent;
    flex-shrink: 0;
    user-select: none;
  }
  .tab:active { background: #2a2a2a; }
  .tab.active { color: #e0e0e0; border-bottom-color: #1565C0; }
  .tab.running { color: #FF9800; }
  .tab.running.active { border-bottom-color: #FF9800; }

  .tab-name {
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* ‚îÄ‚îÄ Âá∫Âäõ„Ç®„É™„Ç¢ ‚îÄ‚îÄ */
  #output-container {
    position: fixed;
    left: 0; right: 0;
    overflow: hidden;
  }

  .output-pane {
    position: absolute;
    inset: 0;
    overflow-y: auto;
    padding: 12px 14px;
    font-family: 'Menlo', 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.65;
    -webkit-overflow-scrolling: touch;
    display: none;
  }
  .output-pane.active { display: block; }

  .line { margin-bottom: 2px; word-break: break-word; white-space: pre-wrap; }
  .line-user    { color: #81C784; }
  .line-text    { color: #e0e0e0; white-space: normal; }
  .line-tool    { color: #64B5F6; font-style: italic; }
  .line-system  { color: #777; font-size: 11px; }
  .line-done    { color: #4CAF50; border-top: 1px solid #333; margin-top: 6px; padding-top: 6px; }
  .line-done.warn { color: #FF9800; }
  #ctx-badge { font-size: 11px; color: #555; flex-shrink: 0; }
  #ctx-badge.warn { color: #FF9800; font-weight: bold; }
  .line-error   { color: #EF5350; }
  .line-queued  { color: #FF9800; font-style: italic; font-size: 12px; }

  /* „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ */
  .line-text p  { margin: 0 0 6px; }
  .line-text p:last-child { margin-bottom: 0; }
  .line-text h1,.line-text h2,.line-text h3 { margin: 8px 0 4px; font-size: 1em; color: #90CAF9; }
  .line-text ul,.line-text ol { padding-left: 18px; margin: 4px 0; }
  .line-text li { margin: 2px 0; }
  .line-text code { background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 3px; padding: 1px 4px; font-family: 'Menlo','Courier New',monospace; font-size: 12px; }
  .line-text pre { background: #222; border: 1px solid #3a3a3a; border-radius: 6px; padding: 10px 12px; margin: 6px 0; overflow-x: auto; }
  .line-text pre code { background: none; border: none; padding: 0; font-size: 12px; }
  .line-text strong { color: #fff; }
  .line-text a { color: #64B5F6; }
  .line-text blockquote { border-left: 3px solid #555; padding-left: 10px; color: #aaa; margin: 4px 0; }

  /* ‚îÄ‚îÄ ÂÖ•Âäõ„Ç®„É™„Ç¢ ‚îÄ‚îÄ */
  #input-area {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: #252525;
    padding: 10px 12px;
    padding-bottom: max(10px, env(safe-area-inset-bottom));
    border-top: 1px solid #3a3a3a;
    z-index: 20;
  }

  #pending-bar {
    display: none;
    margin-bottom: 6px;
    padding: 5px 9px;
    background: #2a1f00;
    border: 1px solid #5a4000;
    border-radius: 6px;
    font-size: 12px;
    color: #FFB74D;
    align-items: center;
    gap: 6px;
  }
  #pending-bar.visible { display: flex; }
  #pending-text { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  #cancel-pending {
    background: none; border: none; color: #888;
    cursor: pointer; font-size: 14px; flex-shrink: 0; padding: 0 2px;
  }

  #input-row { display: flex; gap: 8px; align-items: flex-end; }

  #prompt {
    flex: 1;
    background: #333;
    color: #e0e0e0;
    border: 1px solid #4a4a4a;
    border-radius: 10px;
    padding: 10px 12px;
    font-size: 16px;
    line-height: 1.4;
    resize: none;
    min-height: 42px;
    max-height: 160px;
    font-family: -apple-system, sans-serif;
    outline: none;
  }
  #prompt:focus { border-color: #1565C0; }
  #prompt.has-pending { border-color: #5a4000; }

  #send-btn {
    background: #1565C0;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 11px 14px;
    font-size: 14px;
    cursor: pointer;
    flex-shrink: 0;
    line-height: 1;
    white-space: nowrap;
  }
  #send-btn:active { background: #0D47A1; }
</style>
</head>
<body>

<div id="top-bar">
  <div id="header">
    <div id="status-dot"></div>
    <span id="ctx-badge"></span>
    <select id="model-select">
      <option value="">Sonnet 4.6</option>
      <option value="claude-opus-4-6">Opus 4.6</option>
      <option value="claude-sonnet-4-6">Sonnet 4.6</option>
      <option value="claude-haiku-4-5-20251001">Haiku 4.5</option>
    </select>
    <button id="stop-btn" title="Pause execution">‚è∏</button>
    <button id="reset-btn" title="Reset conversation">‚Ü∫</button>
    <button id="history-btn" title="Conversation history">üìã</button>
    <button id="add-tab-btn" title="New conversation">Ôºã</button>
    <button id="close-tab-btn" title="Close tab">‚úï</button>
  </div>
  <div id="tab-bar"></div>
</div>

<!-- Â±•Ê≠¥„Éë„Éç„É´ -->
<div id="history-panel">
  <div id="history-header">
    <button id="history-back">‚Üê Back</button>
    <span id="history-title">Conversation History</span>
  </div>
  <div id="history-body"></div>
</div>

<div id="output-container"></div>

<div id="input-area">
  <div id="pending-bar">
    <span>Queued: </span>
    <span id="pending-text"></span>
    <button id="cancel-pending" title="„Ç≠„É£„É≥„Çª„É´">‚úï</button>
  </div>
  <div id="input-row">
    <textarea id="prompt" placeholder="Enter prompt..." rows="2"></textarea>
    <button id="send-btn">‚ú®</button>
  </div>
</div>

<script>
const historyBtn    = document.getElementById('history-btn')
const historyPanel  = document.getElementById('history-panel')
const historyBack   = document.getElementById('history-back')
const historyTitle  = document.getElementById('history-title')
const historyBody   = document.getElementById('history-body')
const promptEl      = document.getElementById('prompt')
const sendBtn       = document.getElementById('send-btn')
const statusDot     = document.getElementById('status-dot')
const modelSel      = document.getElementById('model-select')
const resetBtn      = document.getElementById('reset-btn')
const stopBtn       = document.getElementById('stop-btn')
const addTabBtn     = document.getElementById('add-tab-btn')
const closeTabBtn   = document.getElementById('close-tab-btn')
const tabBar        = document.getElementById('tab-bar')
const outputCont    = document.getElementById('output-container')
const pendingBar    = document.getElementById('pending-bar')
const pendingText   = document.getElementById('pending-text')
const cancelPending = document.getElementById('cancel-pending')

const tabState = {}   // tabId -> { isRunning, hasPending, currentTextEl, _rawText, _ctxTokens, pane }
const CTX_MAX = 200000
const ctxBadge = document.getElementById('ctx-badge')
let currentTabId = null
let currentES = null
let _tabsCache = []

// ‚îÄ‚îÄ „Çø„ÉñÁä∂ÊÖãÂàùÊúüÂåñ ‚îÄ‚îÄ
function ensureTabState(tab) {
  if (tabState[tab.id]) return
  const pane = document.createElement('div')
  pane.className = 'output-pane'
  pane.dataset.tabId = tab.id
  outputCont.appendChild(pane)
  tabState[tab.id] = { isRunning: false, hasPending: false, currentTextEl: null, _rawText: '', _ctxTokens: 0, pane, _userInputShown: false }
}

// ‚îÄ‚îÄ „Çø„ÉñDOM‰ΩúÊàê ‚îÄ‚îÄ
function createTabEl(tab) {
  const el = document.createElement('div')
  el.className = 'tab'
  el.dataset.tabId = tab.id

  const name = document.createElement('span')
  name.className = 'tab-name'
  name.textContent = tab.name

  // „ÉÄ„Éñ„É´„Çø„ÉÉ„Éó„ÅßÂêçÂâçÁ∑®ÈõÜ
  let tapTimer = null
  name.addEventListener('click', () => {
    if (tapTimer) {
      clearTimeout(tapTimer); tapTimer = null
      const newName = prompt('‰ºöË©±Âêç„ÇíÂ§âÊõ¥', name.textContent)
      if (newName?.trim()) {
        fetch(`/api/tabs/${tab.id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: newName.trim() })
        }).then(r => r.json()).then(t => { name.textContent = t.name; tab.name = t.name })
      }
    } else {
      tapTimer = setTimeout(() => { tapTimer = null }, 350)
    }
  })

  el.appendChild(name)
  el.addEventListener('click', () => switchTab(tab.id))
  tabBar.appendChild(el)
  return el
}

// ‚îÄ‚îÄ „Çø„ÉñÂâäÈô§ ‚îÄ‚îÄ
async function deleteTab(tabId) {
  const tabs = [...tabBar.querySelectorAll('.tab')]
  if (tabs.length <= 1) { alert('Cannot delete the last tab'); return }
  const res = await fetch(`/api/tabs/${tabId}`, { method: 'DELETE' })
  if (!res.ok) { const e = await res.json(); alert(e.error); return }
  tabBar.querySelector(`[data-tab-id="${tabId}"]`)?.remove()
  tabState[tabId]?.pane.remove()
  delete tabState[tabId]
  _tabsCache = _tabsCache.filter(t => t.id !== tabId)
  if (currentTabId === tabId) {
    if (currentES) { currentES.close(); currentES = null }
    const remaining = [...tabBar.querySelectorAll('.tab')]
    if (remaining.length > 0) switchTab(remaining[0].dataset.tabId)
  }
}

// ‚îÄ‚îÄ „Çø„ÉñÂàá„ÇäÊõø„Åà ‚îÄ‚îÄ
function switchTab(tabId) {
  if (currentES) { currentES.close(); currentES = null }
  tabBar.querySelectorAll('.tab').forEach(t =>
    t.classList.toggle('active', t.dataset.tabId === tabId))
  document.querySelectorAll('.output-pane').forEach(p =>
    p.classList.toggle('active', p.dataset.tabId === tabId))
  currentTabId = tabId
  const switchTs = tabState[tabId]
  if (switchTs) { const p = Math.round(switchTs._ctxTokens / CTX_MAX * 100); updateCtxBadge(p) }
  updateUI()
  connectSSE(tabId)
}

// ‚îÄ‚îÄ ÂàùÊúüÂåñ ‚îÄ‚îÄ
async function init() {
  const tabs = await fetch('/api/tabs').then(r => r.json())
  _tabsCache = tabs
  tabs.forEach(tab => { ensureTabState(tab); createTabEl(tab) })
  if (tabs.length > 0) switchTab(tabs[0].id)
}

// ‚îÄ‚îÄ UIÊõ¥Êñ∞ ‚îÄ‚îÄ
function getTS() { return tabState[currentTabId] || {} }

function updateUI() {
  const ts = getTS()
  const running = ts.isRunning || false
  const pending = ts.hasPending || false
  statusDot.className = running ? 'running' : 'connected'
  stopBtn.classList.toggle('running', running)
  tabBar.querySelectorAll('.tab').forEach(el => {
    const ts2 = tabState[el.dataset.tabId]
    el.classList.toggle('running', ts2?.isRunning || false)
  })
  pendingBar.classList.toggle('visible', pending)
  promptEl.classList.toggle('has-pending', pending)
}

// ‚îÄ‚îÄ SSEÊé•Á∂ö ‚îÄ‚îÄ
function connectSSE(tabId) {
  const es = new EventSource(`/api/stream?tab=${encodeURIComponent(tabId)}`)
  currentES = es
  es.onopen = () => { if (currentTabId === tabId) updateUI() }
  es.onmessage = e => { try { handleEvent(tabId, JSON.parse(e.data)) } catch {} }
  es.onerror = () => { if (currentTabId === tabId) statusDot.className = 'connected' }
}

// ‚îÄ‚îÄ „Ç§„Éô„É≥„ÉàÂá¶ÁêÜ ‚îÄ‚îÄ
function handleEvent(tabId, ev) {
  const ts = tabState[tabId]
  if (!ts) return
  const isActive = tabId === currentTabId

  switch (ev.type) {
    case 'user_input':
      if (!ts._userInputShown) addLine(ts, `> ${ev.text}`, 'line-user')
      ts._userInputShown = true
      finalizeText(ts)
      break

    case 'user': {
      // Claude„ÅåÂá∫Âäõ„Åô„Çã„É¶„Éº„Ç∂„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Ç§„Éô„É≥„ÉàÔºàuser_input„ÅåË°®Á§∫„Åï„Çå„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
      if (!ts._userInputShown) {
        const c = ev.message?.content
        const text = typeof c === 'string' ? c
          : Array.isArray(c) ? c.filter(b => b.type === 'text').map(b => b.text).join('\n')
          : ''
        if (text.trim()) addLine(ts, `> ${text}`, 'line-user')
      }
      break
    }

    case 'start':
      finalizeText(ts)
      ts.isRunning = true
      ts.hasPending = false
      addLine(ts, `‚îÄ‚îÄ ${ev.project} (${ev.model}) ‚îÄ‚îÄ`, 'line-system')
      if (isActive) updateUI()
      break

    case 'stream_event': {
      const inner = ev.event
      switch (inner.type) {
        case 'content_block_delta':
          if (inner.delta?.type === 'text_delta') appendText(ts, inner.delta.text)
          break
        case 'content_block_start':
          finalizeText(ts)
          if (inner.content_block?.type === 'tool_use')
            addLine(ts, `[${inner.content_block.name}]`, 'line-tool')
          break
        case 'content_block_stop':
          finalizeText(ts)
          break
        case 'message_start':
          if (inner.message && inner.message.usage) {
            const u = inner.message.usage
            ts._ctxTokens = (u.input_tokens || 0) + (u.cache_creation_input_tokens || 0) + (u.cache_read_input_tokens || 0)
          }
          break
        case 'message_delta':
          if (inner.usage && inner.usage.output_tokens) {
            ts._ctxTokens += inner.usage.output_tokens
            if (isActive) {
              const pct = Math.round(ts._ctxTokens / CTX_MAX * 100)
              if (pct >= 50) updateCtxBadge(pct)
            }
          }
          break
      }
      break
    }

    case 'done': {
      finalizeText(ts)
      ts.isRunning = false
      ts._userInputShown = false
      const pct = Math.round(ts._ctxTokens / CTX_MAX * 100)
      const doneEl = addLine(ts, `‚úì Done (exit ${ev.exitCode}) ‚Äî ${pct}%`, 'line-done')
      if (pct >= 50) doneEl.classList.add('warn')
      if (isActive) { updateCtxBadge(pct); updateUI() }
      break
    }

    case 'error':
      finalizeText(ts)
      ts.isRunning = false
      addLine(ts, `Error: ${ev.message}`, 'line-error')
      if (isActive) updateUI()
      break

    case 'queued':
      ts.hasPending = true
      addLine(ts, `‚ñ∏ Queued: ${ev.message}`, 'line-queued')
      if (isActive) { pendingText.textContent = ev.message; updateUI() }
      break

    case 'queued_sent':
      ts.hasPending = false
      addLine(ts, `‚ñ∏ Sent: ${ev.message}`, 'line-system')
      if (isActive) updateUI()
      break

    case 'system':
      addLine(ts, ev.text, 'line-system')
      break

    case 'stderr':
      if (ev.text?.trim()) addLine(ts, `[err] ${ev.text}`, 'line-system')
      break
  }
}

function isAtBottom(pane) {
  return pane.scrollHeight - pane.scrollTop - pane.clientHeight < 40
}

function appendText(ts, text) {
  if (!ts.currentTextEl) {
    ts.currentTextEl = document.createElement('div')
    ts.currentTextEl.className = 'line line-text'
    ts.pane.appendChild(ts.currentTextEl)
    ts._rawText = ''
  }
  ts._rawText += text
  ts.currentTextEl.textContent = ts._rawText
  if (tabState[currentTabId] === ts && isAtBottom(ts.pane))
    ts.pane.scrollTop = ts.pane.scrollHeight
}

function finalizeText(ts) {
  if (ts.currentTextEl && ts._rawText) {
    ts.currentTextEl.innerHTML = marked.parse(ts._rawText)
    ts._rawText = ''
  }
  ts.currentTextEl = null
}

function addLine(ts, text, cls) {
  const div = document.createElement('div')
  div.className = `line ${cls}`
  div.textContent = text
  ts.pane.appendChild(div)
  if (tabState[currentTabId] === ts && isAtBottom(ts.pane))
    ts.pane.scrollTop = ts.pane.scrollHeight
  return div
}

function updateCtxBadge(pct) {
  if (pct <= 0) { ctxBadge.textContent = ''; ctxBadge.className = ''; return }
  ctxBadge.textContent = `${pct}%`
  ctxBadge.className = pct >= 50 ? 'warn' : ''
}

// ‚îÄ‚îÄ Â±•Ê≠¥„Éë„Éç„É´ ‚îÄ‚îÄ
function formatDate(iso) {
  if (!iso) return ''
  const d = new Date(iso)
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`
}

async function openHistory() {
  historyPanel.classList.add('open')
  historyBtn.classList.add('active')
  historyTitle.textContent = 'Conversation History'
  historyBack.onclick = closeHistory
  historyBody.innerHTML = '<div style="padding:20px;color:#666;font-size:13px;">Loading...</div>'

  try {
    const sessions = await fetch('/api/history').then(r => r.json())
    historyBody.innerHTML = ''
    if (sessions.length === 0) {
      historyBody.innerHTML = '<div style="padding:20px;color:#666;font-size:13px;">No history available</div>'
      return
    }
    for (const s of sessions) {
      const item = document.createElement('div')
      item.className = 'history-item'
      item.innerHTML = `
        <div class="history-item-title">${escapeHtml(s.title)}</div>
        <div class="history-item-meta">${formatDate(s.updatedAt)} ¬∑ ${s.msgCount}‰ª∂</div>
      `
      item.addEventListener('click', () => openHistoryDetail(s))
      historyBody.appendChild(item)
    }
  } catch (e) {
    historyBody.innerHTML = `<div style="padding:20px;color:#EF5350;font-size:13px;">Error: ${e.message}</div>`
  }
}

async function openHistoryDetail(session) {
  historyTitle.textContent = formatDate(session.updatedAt)
  historyBack.onclick = openHistory
  historyBody.innerHTML = '<div style="padding:20px;color:#666;font-size:13px;">Loading...</div>'

  try {
    const msgs = await fetch(`/api/history/${encodeURIComponent(session.sessionId)}`).then(r => r.json())
    historyBody.innerHTML = ''
    if (msgs.length === 0) {
      historyBody.innerHTML = '<div style="padding:20px;color:#666;font-size:13px;">„É°„ÉÉ„Çª„Éº„Ç∏„Å™„Åó</div>'
      return
    }
    for (const m of msgs) {
      const div = document.createElement('div')
      div.className = `history-msg ${m.role === 'user' ? 'history-msg-user' : 'history-msg-assistant'}`
      div.textContent = m.text
      historyBody.appendChild(div)
    }

    // ÂÜçÈñã„Éú„Çø„É≥
    const resumeBtn = document.createElement('button')
    resumeBtn.id = 'resume-btn'
    resumeBtn.textContent = '„Åì„ÅÆ‰ºöË©±„ÇíÂÜçÈñã'
    resumeBtn.addEventListener('click', () => resumeConversation(session.sessionId))
    historyBody.appendChild(resumeBtn)

    // ÊúÄ‰∏ãÈÉ®„Å´„Çπ„ÇØ„É≠„Éº„É´
    setTimeout(() => {
      historyBody.scrollTop = historyBody.scrollHeight
    }, 100)
  } catch (e) {
    historyBody.innerHTML = `<div style="padding:20px;color:#EF5350;font-size:13px;">Error: ${e.message}</div>`
  }
}

async function resumeConversation(sessionId) {
  try {
    const newTab = await fetch('/api/tabs/fork', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sessionId })
    }).then(r => r.json())

    _tabsCache.push(newTab)
    ensureTabState(newTab)
    createTabEl(newTab)
    switchTab(newTab.id)

    // ÈÅéÂéª„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèñÂæó„Åó„Å¶Ë°®Á§∫
    const msgs = await fetch(`/api/history/${encodeURIComponent(sessionId)}`).then(r => r.json())
    const ts = getTS()
    for (const m of msgs) {
      const role = m.role === 'user' ? 'line-user' : 'line-assistant'
      const prefix = m.role === 'user' ? '> ' : ''
      addLine(ts, prefix + m.text, role)
    }

    closeHistory()
  } catch (e) {
    alert(`Resume error: ${e.message}`)
  }
}

function closeHistory() {
  historyPanel.classList.remove('open')
  historyBtn.classList.remove('active')
}

function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;')
}

historyBtn.addEventListener('click', () => {
  if (historyPanel.classList.contains('open')) closeHistory()
  else openHistory()
})

// ‚îÄ‚îÄ ÈÄÅ‰ø° ‚îÄ‚îÄ
async function send() {
  const prompt = promptEl.value.trim()
  if (!prompt) return
  const ts = getTS()
  promptEl.value = ''
  promptEl.style.height = 'auto'
  ts._userInputShown = true
  addLine(ts, `> ${prompt}`, 'line-user')
  try {
    const res = await fetch('/api/send', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ prompt, tab: currentTabId, model: modelSel.value || null })
    })
    if (!res.ok) {
      addLine(ts, `Send failed: ${(await res.json()).error}`, 'line-error')
    } else {
      const data = await res.json()
      // „Çø„ÉñÂêç„ÅåÂ§â„Çè„Å£„Å¶„ÅÑ„Åü„ÇâÂèçÊò†
      const tabEl = tabBar.querySelector(`[data-tab-id="${currentTabId}"] .tab-name`)
      const cached = _tabsCache.find(t => t.id === currentTabId)
      if (tabEl && cached && tabEl.textContent !== cached.name) {
        const fresh = await fetch('/api/tabs').then(r => r.json())
        _tabsCache = fresh
        const updated = fresh.find(t => t.id === currentTabId)
        if (updated && tabEl.textContent !== updated.name) tabEl.textContent = updated.name
      }
      if (data.queued) {
        ts.hasPending = true
        pendingText.textContent = prompt
        updateUI()
      }
    }
  } catch (e) {
    addLine(ts, `Network error: ${e.message}`, 'line-error')
  }
}

// ‚îÄ‚îÄ „Éú„Çø„É≥ ‚îÄ‚îÄ
stopBtn.addEventListener('click', () => {
  fetch('/api/stop', { method: 'POST', headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tab: currentTabId }) })
})

cancelPending.addEventListener('click', async () => {
  await fetch('/api/stop-pending', { method: 'POST', headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tab: currentTabId }) })
  const ts = getTS(); ts.hasPending = false; updateUI()
})

resetBtn.addEventListener('click', async () => {
  const ts = getTS()
  if (ts.isRunning) { alert('ÂÆüË°å‰∏≠„ÅØ„É™„Çª„ÉÉ„Éà„Åß„Åç„Åæ„Åõ„Çì'); return }
  const tabName = tabBar.querySelector(`[data-tab-id="${currentTabId}"] .tab-name`)?.textContent || ''
  if (!confirm(`„Äå${tabName}„Äç„ÅÆ‰ºöË©±„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü`)) return
  await fetch('/api/reset', { method: 'POST', headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tab: currentTabId }) })
  ts.pane.innerHTML = ''
  ts.currentTextEl = null
  ts._rawText = ''
  ts._ctxTokens = 0
  updateCtxBadge(0)
  addLine(ts, 'Session reset', 'line-system')
})

addTabBtn.addEventListener('click', async () => {
  const newTab = await fetch('/api/tabs', { method: 'POST',
    headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) }).then(r => r.json())
  _tabsCache.push(newTab)
  ensureTabState(newTab)
  createTabEl(newTab)
  switchTab(newTab.id)
})

closeTabBtn.addEventListener('click', () => { if (currentTabId) deleteTab(currentTabId) })

sendBtn.addEventListener('click', send)
promptEl.addEventListener('keydown', e => {
  if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) { e.preventDefault(); send() }
})
promptEl.addEventListener('input', () => {
  promptEl.style.height = 'auto'
  promptEl.style.height = Math.min(promptEl.scrollHeight, 160) + 'px'
  updateLayout()
})

// ‚îÄ‚îÄ „É¨„Ç§„Ç¢„Ç¶„ÉàË®àÁÆóÔºàvisualViewportÂØæÂøúÔºâ ‚îÄ‚îÄ
const topBarEl    = document.getElementById('top-bar')
const inputAreaEl = document.getElementById('input-area')

function updateLayout() {
  const vv = window.visualViewport
  const offsetTop = vv ? vv.offsetTop  : 0
  const vvHeight  = vv ? vv.height     : window.innerHeight

  topBarEl.style.top = offsetTop + 'px'

  const inputH = inputAreaEl.offsetHeight
  inputAreaEl.style.top    = (offsetTop + vvHeight - inputH) + 'px'
  inputAreaEl.style.bottom = 'auto'

  const topH = topBarEl.offsetHeight
  outputCont.style.top    = (offsetTop + topH) + 'px'
  outputCont.style.height = (vvHeight - topH - inputH) + 'px'
  outputCont.style.bottom = 'auto'
}

if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', updateLayout)
  window.visualViewport.addEventListener('scroll', updateLayout)
}
const ro = new ResizeObserver(updateLayout)
ro.observe(topBarEl)
ro.observe(inputAreaEl)
updateLayout()

init()
</script>
</body>
</html>
