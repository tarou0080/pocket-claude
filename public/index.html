<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, interactive-widget=resizes-content">
<title>pocket-claude</title>
<script src="https://cdn.jsdelivr.net/npm/marked@9/marked.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    background: #1a1a1a;
    color: #e0e0e0;
    height: 100%;
    overflow: hidden;
  }

  /* ── 上部固定エリア ── */
  #top-bar {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 20;
  }

  /* ── ヘッダー ── */
  #header {
    background: #252525;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    border-bottom: 1px solid #3a3a3a;
  }

  #status-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: #555;
    flex-shrink: 0;
    transition: background 0.3s;
  }
  #status-dot.connected { background: #4CAF50; }
  #status-dot.running   { background: #FF9800; animation: pulse 1.2s infinite; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

  #model-select {
    background: #333;
    color: #ccc;
    border: 1px solid #4a4a4a;
    padding: 4px 7px;
    border-radius: 6px;
    font-size: 12px;
    flex-shrink: 0;
  }

  #stop-btn, #close-tab-btn, #add-tab-btn, #history-btn {
    background: none;
    border: 1px solid #4a4a4a;
    border-radius: 6px;
    padding: 4px 9px;
    font-size: 12px;
    cursor: pointer;
    flex-shrink: 0;
  }
  #stop-btn { color: #EF5350; border-color: #EF5350; opacity: 0.3; pointer-events: none; }
  #stop-btn.running { opacity: 1; pointer-events: auto; }
  #stop-btn:active { background: #3a2020; }

  #close-tab-btn, #add-tab-btn {
    font-size: 16px;
    padding: 4px 10px;
    color: #888;
    min-width: 36px;
    text-align: center;
    border: none;
  }
  #history-btn {
    font-size: 14px;
    padding: 4px 8px;
    color: #888;
    min-width: 32px;
    text-align: center;
    border: 1px solid #4a4a4a;
    border-radius: 6px;
  }
  #close-tab-btn { margin-left: auto; }
  #close-tab-btn:active, #add-tab-btn:active { background: #3a3a3a; color: #ccc; }
  #history-btn:active { background: #3a3a3a; color: #ccc; }
  #history-btn.active { color: #64B5F6; border-color: #64B5F6; }

  /* ── 履歴パネル ── */
  #history-panel {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 30;
    background: #1a1a1a;
    flex-direction: column;
  }
  #history-panel.open { display: flex; }

  #history-header {
    background: #252525;
    padding: 10px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    border-bottom: 1px solid #3a3a3a;
    flex-shrink: 0;
  }
  #history-back {
    background: none;
    border: none;
    color: #64B5F6;
    font-size: 14px;
    cursor: pointer;
    padding: 4px 6px;
    border-radius: 6px;
  }
  #history-back:active { background: #2a2a2a; }
  #history-title {
    font-size: 14px;
    color: #e0e0e0;
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  #history-body {
    flex: 1;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* 一覧 */
  .history-item {
    padding: 12px 14px;
    border-bottom: 1px solid #2a2a2a;
    cursor: pointer;
    user-select: none;
  }
  .history-item:active { background: #252525; }
  .history-item-title {
    font-size: 13px;
    color: #e0e0e0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 3px;
  }
  .history-item-meta {
    font-size: 11px;
    color: #666;
  }

  /* 詳細 */
  .history-msg {
    padding: 10px 14px;
    border-bottom: 1px solid #252525;
    font-size: 13px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
  }
  .history-msg-user { color: #81C784; background: #1e2a1e; }
  .history-msg-assistant { color: #e0e0e0; }

  /* 再開ボタン */
  #resume-btn {
    margin: 20px 14px;
    padding: 14px 20px;
    background: #1565C0;
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 15px;
    cursor: pointer;
    width: calc(100% - 28px);
    text-align: center;
  }
  #resume-btn:active { background: #0D47A1; }

  /* ── タブバー ── */
  #tab-bar {
    background: #1e1e1e;
    border-bottom: 1px solid #3a3a3a;
    display: flex;
    align-items: stretch;
    overflow-x: auto;
    scrollbar-width: none;
  }
  #tab-bar::-webkit-scrollbar { display: none; }

  .tab {
    display: flex;
    align-items: center;
    padding: 8px 14px;
    font-size: 13px;
    color: #888;
    cursor: pointer;
    white-space: nowrap;
    border-bottom: 2px solid transparent;
    flex-shrink: 0;
    user-select: none;
  }
  .tab:active { background: #2a2a2a; }
  .tab.active { color: #e0e0e0; border-bottom-color: #1565C0; }
  .tab.running { color: #FF9800; }
  .tab.running.active { border-bottom-color: #FF9800; }

  .tab-name {
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* ── 出力エリア ── */
  #output-container {
    position: fixed;
    left: 0; right: 0;
    overflow: hidden;
  }

  .output-pane {
    position: absolute;
    inset: 0;
    overflow-y: auto;
    padding: 12px 14px;
    font-family: 'Menlo', 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.65;
    -webkit-overflow-scrolling: touch;
    display: none;
  }
  .output-pane.active { display: block; }

  .line { margin-bottom: 2px; word-break: break-word; white-space: pre-wrap; }
  .line-user    { color: #81C784; }
  .line-text    { color: #e0e0e0; white-space: normal; }
  .line-tool    { color: #64B5F6; cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px; }
  .line-tool .tool-name { font-style: italic; flex-shrink: 0; }
  .line-tool .tool-desc { color: #888; font-size: 11px; font-style: normal; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .line-tool .tool-toggle { font-size: 10px; color: #666; flex-shrink: 0; }
  .tool-result { color: #777; font-size: 11px; margin-left: 20px; margin-top: 2px; white-space: pre-wrap; overflow-x: auto; max-height: 0; overflow-y: hidden; transition: max-height 0.2s; }
  .tool-result.expanded { max-height: 500px; overflow-y: auto; }
  .line-system  { color: #777; font-size: 11px; }
  .line-done    { color: #4CAF50; border-top: 1px solid #333; margin-top: 6px; padding-top: 6px; }
  .line-done.warn { color: #FF9800; }
  #ctx-badge { font-size: 11px; color: #555; flex-shrink: 0; }
  #ctx-badge.warn { color: #FF9800; font-weight: bold; }
  .line-error   { color: #EF5350; }

  /* マークダウン */
  .line-text p  { margin: 0 0 6px; }
  .line-text p:last-child { margin-bottom: 0; }
  .line-text h1,.line-text h2,.line-text h3 { margin: 8px 0 4px; font-size: 1em; color: #90CAF9; }
  .line-text ul,.line-text ol { padding-left: 18px; margin: 4px 0; }
  .line-text li { margin: 2px 0; }
  .line-text code { background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 3px; padding: 1px 4px; font-family: 'Menlo','Courier New',monospace; font-size: 12px; }
  .line-text pre { background: #222; border: 1px solid #3a3a3a; border-radius: 6px; padding: 10px 12px; margin: 6px 0; overflow-x: auto; }
  .line-text pre code { background: none; border: none; padding: 0; font-size: 12px; }
  .line-text strong { color: #fff; }
  .line-text a { color: #64B5F6; }
  .line-text blockquote { border-left: 3px solid #555; padding-left: 10px; color: #aaa; margin: 4px 0; }

  /* ── 入力エリア ── */
  #input-area {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: #252525;
    padding: 10px 12px;
    padding-bottom: max(10px, env(safe-area-inset-bottom));
    border-top: 1px solid #3a3a3a;
    z-index: 20;
  }

  #input-row { display: flex; gap: 8px; align-items: flex-end; }

  #prompt {
    flex: 1;
    background: #333;
    color: #e0e0e0;
    border: 1px solid #4a4a4a;
    border-radius: 10px;
    padding: 10px 12px;
    font-size: 16px;
    line-height: 1.4;
    resize: none;
    min-height: 42px;
    max-height: 160px;
    font-family: -apple-system, sans-serif;
    outline: none;
  }
  #prompt:focus { border-color: #1565C0; }

  #send-btn {
    background: #1565C0;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 11px 14px;
    font-size: 14px;
    cursor: pointer;
    flex-shrink: 0;
    line-height: 1;
    white-space: nowrap;
  }
  #send-btn:active { background: #0D47A1; }
</style>
</head>
<body>

<div id="top-bar">
  <div id="header">
    <div id="status-dot"></div>
    <span id="ctx-badge"></span>
    <select id="model-select">
      <option value="">Sonnet 4.6</option>
      <option value="claude-opus-4-6">Opus 4.6</option>
      <option value="claude-sonnet-4-6">Sonnet 4.6</option>
      <option value="claude-haiku-4-5-20251001">Haiku 4.5</option>
    </select>
    <button id="stop-btn" title="Stop execution">■</button>
    <button id="history-btn" title="Conversation history">⟳</button>
    <button id="add-tab-btn" title="New conversation">+</button>
    <button id="close-tab-btn" title="Close tab">✕</button>
  </div>
  <div id="tab-bar"></div>
</div>

<!-- 履歴パネル -->
<div id="history-panel">
  <div id="history-header">
    <button id="history-back">← Back</button>
    <span id="history-title">Conversation History</span>
  </div>
  <div id="history-body"></div>
</div>

<div id="output-container"></div>

<div id="input-area">
  <div id="input-row">
    <textarea id="prompt" placeholder="Enter prompt..." rows="2"></textarea>
    <button id="send-btn">✨</button>
  </div>
</div>

<script>
const historyBtn    = document.getElementById('history-btn')
const historyPanel  = document.getElementById('history-panel')
const historyBack   = document.getElementById('history-back')
const historyTitle  = document.getElementById('history-title')
const historyBody   = document.getElementById('history-body')
const promptEl      = document.getElementById('prompt')
const sendBtn       = document.getElementById('send-btn')
const statusDot     = document.getElementById('status-dot')
const modelSel      = document.getElementById('model-select')
const stopBtn       = document.getElementById('stop-btn')
const addTabBtn     = document.getElementById('add-tab-btn')
const closeTabBtn   = document.getElementById('close-tab-btn')
const tabBar        = document.getElementById('tab-bar')
const outputCont    = document.getElementById('output-container')

const tabState = {}   // tabId -> { isRunning, currentTextEl, _rawText, _ctxTokens, pane, autoScroll }
const CTX_MAX = 200000
const ctxBadge = document.getElementById('ctx-badge')
let currentTabId = null
let currentES = null
let _tabsCache = []

// ── タブ状態初期化 ──
function ensureTabState(tab) {
  if (tabState[tab.id]) return
  const pane = document.createElement('div')
  pane.className = 'output-pane'
  pane.dataset.tabId = tab.id
  outputCont.appendChild(pane)
  tabState[tab.id] = {
    isRunning: false,
    currentTextEl: null,
    _rawText: '',
    _ctxTokens: 0,
    pane,
    _userInputShown: false,
    autoScroll: true  // デフォルトで自動スクロール有効
  }

  // ユーザーが手動でスクロールしたら自動スクロールを無効化
  pane.addEventListener('scroll', () => {
    const ts = tabState[tab.id]
    if (!ts) return
    // 最下部から100px以内なら自動スクロール再開
    if (isAtBottom(pane, 100)) {
      ts.autoScroll = true
    } else {
      ts.autoScroll = false
    }
  })
}

// ── タブDOM作成 ──
function createTabEl(tab) {
  const el = document.createElement('div')
  el.className = 'tab'
  el.dataset.tabId = tab.id

  const name = document.createElement('span')
  name.className = 'tab-name'
  name.textContent = tab.name

  // ダブルタップで名前編集
  let tapTimer = null
  name.addEventListener('click', () => {
    if (tapTimer) {
      clearTimeout(tapTimer); tapTimer = null
      const newName = prompt('会話名を変更', name.textContent)
      if (newName?.trim()) {
        fetch(`/api/tabs/${tab.id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: newName.trim() })
        }).then(r => r.json()).then(t => { name.textContent = t.name; tab.name = t.name })
      }
    } else {
      tapTimer = setTimeout(() => { tapTimer = null }, 350)
    }
  })

  el.appendChild(name)
  el.addEventListener('click', () => switchTab(tab.id))
  tabBar.appendChild(el)
  return el
}

// ── タブ削除 ──
async function deleteTab(tabId) {
  const tabs = [...tabBar.querySelectorAll('.tab')]
  const res = await fetch(`/api/tabs/${tabId}`, { method: 'DELETE' })
  if (!res.ok) { const e = await res.json(); alert(e.error); return }
  tabBar.querySelector(`[data-tab-id="${tabId}"]`)?.remove()
  tabState[tabId]?.pane.remove()
  delete tabState[tabId]
  _tabsCache = _tabsCache.filter(t => t.id !== tabId)
  if (currentTabId === tabId) {
    if (currentES) { currentES.close(); currentES = null }
    const remaining = [...tabBar.querySelectorAll('.tab')]
    if (remaining.length > 0) {
      switchTab(remaining[0].dataset.tabId)
    } else {
      // 最後のタブを削除したので新規タブを作成
      const newTab = await fetch('/api/tabs', { method: 'POST',
        headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) }).then(r => r.json())
      _tabsCache.push(newTab)
      ensureTabState(newTab)
      createTabEl(newTab)
      switchTab(newTab.id)
    }
  }
}

// ── タブ切り替え ──
function switchTab(tabId) {
  if (currentES) { currentES.close(); currentES = null }
  tabBar.querySelectorAll('.tab').forEach(t =>
    t.classList.toggle('active', t.dataset.tabId === tabId))
  document.querySelectorAll('.output-pane').forEach(p =>
    p.classList.toggle('active', p.dataset.tabId === tabId))
  currentTabId = tabId
  const switchTs = tabState[tabId]
  if (switchTs) { const p = Math.round(switchTs._ctxTokens / CTX_MAX * 100); updateCtxBadge(p) }
  updateUI()
  connectSSE(tabId)
}

// ── 初期化 ──
async function init() {
  const tabs = await fetch('/api/tabs').then(r => r.json())
  _tabsCache = tabs
  tabs.forEach(tab => { ensureTabState(tab); createTabEl(tab) })
  if (tabs.length > 0) switchTab(tabs[0].id)
}

// ── UI更新 ──
function getTS() { return tabState[currentTabId] || {} }

function updateUI() {
  const ts = getTS()
  const running = ts.isRunning || false
  statusDot.className = running ? 'running' : 'connected'
  stopBtn.classList.toggle('running', running)
  tabBar.querySelectorAll('.tab').forEach(el => {
    const ts2 = tabState[el.dataset.tabId]
    el.classList.toggle('running', ts2?.isRunning || false)
  })
}

// ── SSE接続 ──
function connectSSE(tabId) {
  const es = new EventSource(`/api/stream?tab=${encodeURIComponent(tabId)}`)
  currentES = es
  es.onopen = () => { if (currentTabId === tabId) updateUI() }
  es.onmessage = e => { try { handleEvent(tabId, JSON.parse(e.data)) } catch {} }
  es.onerror = () => { if (currentTabId === tabId) statusDot.className = 'connected' }
}

// ── イベント処理 ──
function handleEvent(tabId, ev) {
  const ts = tabState[tabId]
  if (!ts) return
  const isActive = tabId === currentTabId

  switch (ev.type) {
    case 'user_input':
      if (!ts._userInputShown) addLine(ts, `> ${ev.text}`, 'line-user')
      ts._userInputShown = true
      finalizeText(ts)
      break

    case 'user': {
      // Claudeが出力するユーザーメッセージイベント（user_inputが表示されなかった場合のフォールバック）
      if (!ts._userInputShown) {
        const c = ev.message?.content
        const text = typeof c === 'string' ? c
          : Array.isArray(c) ? c.filter(b => b.type === 'text').map(b => b.text).join('\n')
          : ''
        if (text.trim()) addLine(ts, `> ${text}`, 'line-user')
      }
      break
    }

    case 'start':
      finalizeText(ts)
      ts.isRunning = true
      addLine(ts, `── ${ev.project} (${ev.model}) ──`, 'line-system')
      if (isActive) updateUI()
      break

    case 'stream_event': {
      const inner = ev.event
      switch (inner.type) {
        case 'content_block_delta':
          if (inner.delta?.type === 'text_delta') appendText(ts, inner.delta.text)
          else if (inner.delta?.type === 'input_json_delta' && ts._currentToolEl) {
            ts._currentToolInput = (ts._currentToolInput || '') + (inner.delta.partial_json || '')
          }
          break
        case 'content_block_start':
          finalizeText(ts)
          if (inner.content_block?.type === 'tool_use') {
            const toolName = inner.content_block.name || 'Tool'
            ts._currentToolEl = addToolLine(ts, toolName, inner.content_block.id)
            ts._currentToolInput = ''
          }
          break
        case 'content_block_stop':
          finalizeText(ts)
          if (ts._currentToolEl && ts._currentToolInput) {
            try {
              const params = JSON.parse(ts._currentToolInput)
              updateToolDesc(ts._currentToolEl, params)
            } catch {}
          }
          ts._currentToolEl = null
          ts._currentToolInput = ''
          break
        case 'message_start':
          if (inner.message && inner.message.usage) {
            const u = inner.message.usage
            ts._ctxTokens = (u.input_tokens || 0) + (u.cache_creation_input_tokens || 0) + (u.cache_read_input_tokens || 0)
          }
          break
        case 'message_delta':
          if (inner.usage && inner.usage.output_tokens) {
            ts._ctxTokens += inner.usage.output_tokens
            if (isActive) {
              const pct = Math.round(ts._ctxTokens / CTX_MAX * 100)
              if (pct >= 50) updateCtxBadge(pct)
            }
          }
          break
      }
      break
    }

    case 'done': {
      finalizeText(ts)
      ts.isRunning = false
      ts._userInputShown = false
      const pct = Math.round(ts._ctxTokens / CTX_MAX * 100)
      const doneEl = addLine(ts, `✓ Done (exit ${ev.exitCode}) — ${pct}%`, 'line-done')
      if (pct >= 50) doneEl.classList.add('warn')
      if (isActive) { updateCtxBadge(pct); updateUI() }
      break
    }

    case 'error':
      finalizeText(ts)
      ts.isRunning = false
      addLine(ts, `Error: ${ev.message}`, 'line-error')
      if (isActive) updateUI()
      break

    case 'system':
      addLine(ts, ev.text, 'line-system')
      break

    case 'stderr':
      if (ev.text?.trim()) addLine(ts, `[err] ${ev.text}`, 'line-system')
      break
  }
}

function isAtBottom(pane, threshold = 100) {
  return pane.scrollHeight - pane.scrollTop - pane.clientHeight < threshold
}

function scrollToBottom(ts) {
  if (ts.autoScroll && tabState[currentTabId] === ts) {
    requestAnimationFrame(() => {
      ts.pane.scrollTop = ts.pane.scrollHeight
    })
  }
}

function appendText(ts, text) {
  if (!ts.currentTextEl) {
    ts.currentTextEl = document.createElement('div')
    ts.currentTextEl.className = 'line line-text'
    ts.pane.appendChild(ts.currentTextEl)
    ts._rawText = ''
  }
  ts._rawText += text
  ts.currentTextEl.textContent = ts._rawText
  scrollToBottom(ts)
}

function finalizeText(ts) {
  if (ts.currentTextEl && ts._rawText) {
    ts.currentTextEl.innerHTML = marked.parse(ts._rawText)
    ts._rawText = ''
  }
  ts.currentTextEl = null
}

function addLine(ts, text, cls) {
  const div = document.createElement('div')
  div.className = `line ${cls}`
  div.textContent = text
  ts.pane.appendChild(div)
  scrollToBottom(ts)
  return div
}

function addToolLine(ts, toolName, toolId) {
  const div = document.createElement('div')
  div.className = 'line line-tool'
  div.dataset.toolId = toolId

  const nameSpan = document.createElement('span')
  nameSpan.className = 'tool-name'
  nameSpan.textContent = `[${toolName}]`

  const descSpan = document.createElement('span')
  descSpan.className = 'tool-desc'
  descSpan.textContent = ''

  const toggleSpan = document.createElement('span')
  toggleSpan.className = 'tool-toggle'
  toggleSpan.textContent = '▸'

  div.appendChild(nameSpan)
  div.appendChild(descSpan)
  div.appendChild(toggleSpan)

  const resultDiv = document.createElement('div')
  resultDiv.className = 'tool-result'

  div.addEventListener('click', () => {
    const expanded = resultDiv.classList.toggle('expanded')
    toggleSpan.textContent = expanded ? '▾' : '▸'
  })

  ts.pane.appendChild(div)
  ts.pane.appendChild(resultDiv)

  div._resultDiv = resultDiv
  scrollToBottom(ts)
  return div
}

function updateToolDesc(toolEl, params) {
  const descSpan = toolEl.querySelector('.tool-desc')
  if (!descSpan) return

  const toolName = toolEl.querySelector('.tool-name')?.textContent.replace(/[\[\]]/g, '') || ''
  let desc = ''

  switch (toolName) {
    case 'Bash':
      desc = params.command ? params.command.substring(0, 60) : ''
      break
    case 'Read':
      desc = params.file_path ? params.file_path : ''
      break
    case 'Edit':
      desc = params.file_path ? params.file_path : ''
      break
    case 'Write':
      desc = params.file_path ? params.file_path : ''
      break
    case 'Grep':
      desc = params.pattern ? `"${params.pattern}"${params.path ? ' in ' + params.path : ''}` : ''
      break
    case 'Glob':
      desc = params.pattern ? params.pattern : ''
      break
    default:
      desc = Object.keys(params).slice(0, 2).map(k => `${k}: ${String(params[k]).substring(0, 30)}`).join(', ')
  }

  descSpan.textContent = desc
}

function updateCtxBadge(pct) {
  if (pct <= 0) { ctxBadge.textContent = ''; ctxBadge.className = ''; return }
  ctxBadge.textContent = `${pct}%`
  ctxBadge.className = pct >= 50 ? 'warn' : ''
}

// ── 履歴パネル ──
function formatDate(iso) {
  if (!iso) return ''
  const d = new Date(iso)
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`
}

async function openHistory() {
  historyPanel.classList.add('open')
  historyBtn.classList.add('active')
  historyTitle.textContent = 'Conversation History'
  historyBack.onclick = closeHistory
  historyBody.innerHTML = '<div style="padding:20px;color:#666;font-size:13px;">Loading...</div>'

  try {
    const sessions = await fetch('/api/history').then(r => r.json())
    historyBody.innerHTML = ''
    if (sessions.length === 0) {
      historyBody.innerHTML = '<div style="padding:20px;color:#666;font-size:13px;">No history available</div>'
      return
    }
    for (const s of sessions) {
      const item = document.createElement('div')
      item.className = 'history-item'
      item.innerHTML = `
        <div class="history-item-title">${escapeHtml(s.title)}</div>
        <div class="history-item-meta">${formatDate(s.updatedAt)} · ${s.msgCount}件</div>
      `
      item.addEventListener('click', () => openHistoryDetail(s))
      historyBody.appendChild(item)
    }
  } catch (e) {
    historyBody.innerHTML = `<div style="padding:20px;color:#EF5350;font-size:13px;">Error: ${e.message}</div>`
  }
}

async function openHistoryDetail(session) {
  historyTitle.textContent = formatDate(session.updatedAt)
  historyBack.onclick = openHistory
  historyBody.innerHTML = '<div style="padding:20px;color:#666;font-size:13px;">Loading...</div>'

  try {
    const msgs = await fetch(`/api/history/${encodeURIComponent(session.sessionId)}`).then(r => r.json())
    historyBody.innerHTML = ''
    if (msgs.length === 0) {
      historyBody.innerHTML = '<div style="padding:20px;color:#666;font-size:13px;">メッセージなし</div>'
      return
    }
    for (const m of msgs) {
      const div = document.createElement('div')
      div.className = `history-msg ${m.role === 'user' ? 'history-msg-user' : 'history-msg-assistant'}`
      div.textContent = m.text
      historyBody.appendChild(div)
    }

    // 再開ボタン
    const resumeBtn = document.createElement('button')
    resumeBtn.id = 'resume-btn'
    resumeBtn.textContent = 'この会話を再開'
    resumeBtn.addEventListener('click', () => resumeConversation(session.sessionId))
    historyBody.appendChild(resumeBtn)

    // 最下部にスクロール
    setTimeout(() => {
      historyBody.scrollTop = historyBody.scrollHeight
    }, 100)
  } catch (e) {
    historyBody.innerHTML = `<div style="padding:20px;color:#EF5350;font-size:13px;">Error: ${e.message}</div>`
  }
}

async function resumeConversation(sessionId) {
  try {
    const newTab = await fetch('/api/tabs/fork', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sessionId })
    }).then(r => r.json())

    _tabsCache.push(newTab)
    ensureTabState(newTab)
    createTabEl(newTab)
    switchTab(newTab.id)

    // 過去のメッセージを取得して表示
    const msgs = await fetch(`/api/history/${encodeURIComponent(sessionId)}`).then(r => r.json())
    const ts = getTS()
    for (const m of msgs) {
      const role = m.role === 'user' ? 'line-user' : 'line-assistant'
      const prefix = m.role === 'user' ? '> ' : ''
      addLine(ts, prefix + m.text, role)
    }

    closeHistory()
  } catch (e) {
    alert(`Resume error: ${e.message}`)
  }
}

function closeHistory() {
  historyPanel.classList.remove('open')
  historyBtn.classList.remove('active')
}

function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;')
}

historyBtn.addEventListener('click', () => {
  if (historyPanel.classList.contains('open')) closeHistory()
  else openHistory()
})

// ── 送信 ──
async function send() {
  const prompt = promptEl.value.trim()
  if (!prompt) return
  const ts = getTS()
  promptEl.value = ''
  promptEl.style.height = 'auto'
  ts._userInputShown = true
  addLine(ts, `> ${prompt}`, 'line-user')
  try {
    const res = await fetch('/api/send', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ prompt, tab: currentTabId, model: modelSel.value || null })
    })
    if (!res.ok) {
      addLine(ts, `Send failed: ${(await res.json()).error}`, 'line-error')
    } else {
      // タブ名が変わっていたら反映
      const tabEl = tabBar.querySelector(`[data-tab-id="${currentTabId}"] .tab-name`)
      const cached = _tabsCache.find(t => t.id === currentTabId)
      if (tabEl && cached && tabEl.textContent !== cached.name) {
        const fresh = await fetch('/api/tabs').then(r => r.json())
        _tabsCache = fresh
        const updated = fresh.find(t => t.id === currentTabId)
        if (updated && tabEl.textContent !== updated.name) tabEl.textContent = updated.name
      }
    }
  } catch (e) {
    addLine(ts, `Network error: ${e.message}`, 'line-error')
  }
}

// ── ボタン ──
stopBtn.addEventListener('click', () => {
  fetch('/api/stop', { method: 'POST', headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tab: currentTabId }) })
})

addTabBtn.addEventListener('click', async () => {
  const newTab = await fetch('/api/tabs', { method: 'POST',
    headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) }).then(r => r.json())
  _tabsCache.push(newTab)
  ensureTabState(newTab)
  createTabEl(newTab)
  switchTab(newTab.id)
})

closeTabBtn.addEventListener('click', () => { if (currentTabId) deleteTab(currentTabId) })

sendBtn.addEventListener('click', send)
promptEl.addEventListener('keydown', e => {
  if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) { e.preventDefault(); send() }
})
promptEl.addEventListener('input', () => {
  promptEl.style.height = 'auto'
  promptEl.style.height = Math.min(promptEl.scrollHeight, 160) + 'px'
  updateLayout()

  // 入力フォームが拡大しても、自動スクロール中なら最下部を維持
  const ts = getTS()
  if (ts && ts.autoScroll) {
    scrollToBottom(ts)
  }
})

// ── レイアウト計算（visualViewport対応） ──
const topBarEl    = document.getElementById('top-bar')
const inputAreaEl = document.getElementById('input-area')

function updateLayout() {
  const vv = window.visualViewport
  const offsetTop = vv ? vv.offsetTop  : 0
  const vvHeight  = vv ? vv.height     : window.innerHeight

  topBarEl.style.top = offsetTop + 'px'

  const inputH = inputAreaEl.offsetHeight
  inputAreaEl.style.top    = (offsetTop + vvHeight - inputH) + 'px'
  inputAreaEl.style.bottom = 'auto'

  const topH = topBarEl.offsetHeight
  outputCont.style.top    = (offsetTop + topH) + 'px'
  outputCont.style.height = (vvHeight - topH - inputH) + 'px'
  outputCont.style.bottom = 'auto'
}

if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', updateLayout)
  window.visualViewport.addEventListener('scroll', updateLayout)
}
const ro = new ResizeObserver(updateLayout)
ro.observe(topBarEl)
ro.observe(inputAreaEl)
updateLayout()

init()
</script>
</body>
</html>
